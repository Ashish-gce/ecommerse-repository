const mongoose = require("mongoose");
const validator = require("validator");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const crypto = require("crypto"); // generating random bites in our application

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, "Please Enter your Name"],
    maxlength: [30, "Name cannot exceed 30 character"],
    minlength: [4, "Name should have more than 4 character"],
  },

  email: {
    type: String,
    required: [true, "Please Enter your Email"],
    unique: true,
    validate: [validator.isEmail, "Please Enter a valid Email"],
  },

  password: {
    type: String,
    required: [true, "Please Enter Your Password"],
    minlength: [
      8,
      "Password should be greater than or equal to (>=) 8 characters",
    ],
    select: false, // ðŸ‘¿ NOTE:- when we type Ex= "user.find()" -> then it gives all details @ user's except 'password'
  },

  avatar: {
    //   'public_id'  &&  'url'  we getting from "CLOUDNARY" -> online
    public_id: {
      type: String,
      required: true,
    },
    url: {
      type: String,
      required: true,
    },
  },

  //   until we make them  "Admin"  default every login person is 'user'
  role: {
    type: String,
    default: "user",
  },

  createdAt: {
    type: Date,
    default: Date.now,
  },

  resetPasswordToken: String,
  resetPasswordExpire: Date,
});

//  here we've to "encrypt" the password before sending it to the DataBase

//  below is an ðŸ“”ðŸ“”ðŸ“” 'event'  which is used / happen just before (.pre)  "save".
//  â›”â›”â›” since, 'Arrow-function' -> not properly work with  "this"  keyword. So we're using normal function()
userSchema.pre("save", async function (next) {
  //  if user only modify it's (name, email) !password then we don't do anything with password (don't encrypt the encrypted password again -> WRONG)
  if (!this.isModified("password")) {
    next();
  }

  //  executes for "fresh"  password or modified password
  this.password = await bcrypt.hash(this.password, 10); // Encrypt our password into 'hash-code'
});

//  ðŸ¥‡ðŸ¥‡ JWT TOKEN -> for registeation automatically login
userSchema.methods.getJWTToken = function () {
  //  here making jsonwebtoken by -> ( user's_id (individual user's id -> generated by mongodb), SECREAT_KEY -> (jwt_secret_key) )

  return jwt.sign({ id: this._id }, process.env.JWT_SECRET_KEY, {
    expiresIn: process.env.JWT_EXPIRE, //  "expiresIn" is predefined property of  'jsonwebtoken'
    //  after this day our token validation is expire automatically
  });
};

// ðŸ¥‡ðŸ¥‡ compare Password
userSchema.methods.comparePassword = async function (enterPassword) {
  // already password present in DB in 'encrypted' form -> for compare 'bcrypt' them
  return await bcrypt.compare(enterPassword, this.password); // 'this.password' -> comes from DB (hash / encrypted password)
};

//  ðŸ¥‡ðŸ¥‡ ðŸ“´ðŸ“´ Generating Password Reset Token
userSchema.methods.getResetPasswordToken = function () {
  // Generating Token
  //  // ðŸš¢ðŸš¢ 'crypto.pseudoRandomBytes(20)' -> generating some random 'bytes' a/c to our arguments
  const resetToken = crypto.pseudoRandomBytes(20).toString("hex"); // generate a 'token' 20-random-bytes

  //  Hashing and adding resetPasswordToken to userSchema
  this.resetPasswordToken = crypto
    .createHash("sha256")
    .update(resetToken)
    .digest("hex");

  //  ðŸ‘¿ðŸ‘¿ After Hoe much time ? -> our generated code get expire -> How much time our generated code till valid
  this.resetPasswordExpire = Date.now() + 15 * 60 * 1000; // 15-min === 15*60*1000 msec

  return resetToken; // now, 'resetToken' return to 'getResetPasswordToken()' -> above
};

module.exports = mongoose.model("user", userSchema); // here  'user' -> name of table
